import WFSFormat from 'ol/format/WFS';
import dispatcher from './editdispatcher';

const format = new WFSFormat();
const serializer = new XMLSerializer();

function readResponse(data) {
  let result;
  if (window.Document && data instanceof Document && data.documentElement && data.documentElement.localName === 'ExceptionReport') {
    alert(data.getElementsByTagNameNS('http://www.opengis.net/ows', 'ExceptionText').item(0).textContent);
  } else {
    result = format.readTransactionResponse(data);
  }

  return result;
}

function writeWfsTransaction(transObj, options, reuseIds) {
  // FIXME: This doesn't do anything. It just deletes the key from the feat object, which is a deep copy of feature's values
  // and if it did something it would delete an attribute, which probably is a bad thing in itself
  // but also since it would prevent setting the attribute to empty string, which might would be the desired action.
  if (transObj.insert) {
    transObj.insert.forEach((feature) => {
      const props = feature.getProperties();
      Object.keys(props).forEach(prop => (props[prop] === '') && feature.unset(prop));
    });
  }
  const node = format.writeTransaction(transObj.insert, transObj.update, transObj.delete, options);

  // Set id and use id when id should be recreated
  // This happens when a delete feature is undone after it has been saved. It will then be creted as a new insert
  // and if id is used as foreign key in a relation the relation will break. In such cases we can try to tell WFS
  // to create the id the feature had before it got deleted. Support for this is probably not widespread.
  if (reuseIds) {
    // We can't send this info to openLayer's serializer, so we have to search in the output and inject the magic
    // attribute "idgen". This code only works for WFS 1.1.0. Luckily for us, that's what OL uses by default.
    // It also requires that the database support insert to id columns. In postgres the column should be set to
    // something like ADD COLUMN fid bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 );
    // where the key ingredient is "GENERATED BY DEFAULT" instead of the usual "GENERATED ALWAYS"
    node.childNodes.forEach(currNode => {
      if (currNode.nodeName === 'Insert') {
        // Check if we should try to reuse ids
        if (!currNode.firstChild.attributes.fid.value.startsWith('origotmp:')) {
          const useFidAttr = document.createAttribute('idgen');
          useFidAttr.value = 'UseExisting';
          currNode.attributes.setNamedItem(useFidAttr);
        }
      }
    });
  }
  return node;
}

function wfsTransaction(transObj, layerName, viewer, opts) {
  const {
    reuseIds
  } = opts;
  const srsName = viewer.getProjectionCode();
  const layer = viewer.getLayer(layerName);
  const featureType = layer.get('featureType');

  const source = viewer.getMapSource()[layer.get('sourceName')];
  const options = {
    gmlOptions: {
      srsName
    },
    featureNS: source.workspace,
    featurePrefix: source.prefix,
    featureType
  };
  const node = writeWfsTransaction(transObj, options, reuseIds);

  function error(e) {
    const errorMsg = e ? (`${e.status} ${e.statusText}`) : '';
    alert(`Det inträffade ett fel när ändringarna skulle sparas till servern...
      ${errorMsg}`);
  }

  function success(data) {
    const result = readResponse(data);
    let feature;
    if (result) {
      if (result.transactionSummary.totalUpdated > 0) {
        dispatcher.emitChangeFeature({
          feature: transObj.update,
          layerName,
          status: 'finished',
          action: 'update'
        });
      }

      if (result.transactionSummary.totalDeleted > 0) {
        dispatcher.emitChangeFeature({
          feature: transObj.delete,
          layerName,
          status: 'finished',
          action: 'delete'
        });
      }

      if (result.transactionSummary.totalInserted > 0) {
        feature = transObj.insert;

        dispatcher.emitChangeFeature({
          feature: transObj.insert,
          layerName,
          status: 'finished',
          action: 'insert'
        });
        const insertIds = result.insertIds;
        insertIds.forEach((insertId, index) => feature[index].setId(insertId));
      }
    } else {
      error();
    }
  }

  const header = new Headers();
  header.append('Content-Type', 'text/plain');
  return fetch(source.url, {
    method: 'POST',
    body: serializer.serializeToString(node),
    headers: header,
    redirect: 'follow'
  })
    .then(res => res.text())
    .then(str => (new window.DOMParser()).parseFromString(str, 'text/xml'))
    .then((data) => {
      success(data);
      const result = readResponse(data);
      let nr = 0;
      if (result) {
        nr += result.transactionSummary.totalUpdated;
        nr += result.transactionSummary.totalDeleted;
        nr += result.transactionSummary.totalInserted;
      }
      return nr;
    })
    .catch(err => error(err));
}

export default function wfstransaction(transObj, layerName, viewer, options = {}) {
  return wfsTransaction(transObj, layerName, viewer, options);
}
